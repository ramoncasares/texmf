/* index.c (RMCG20051228) */

#include <stdio.h>
#include <string.h>
#include <regex.h>

/* Creates an abc file from a ind file and an ndx file. */

/* Note: readtex should be executed on the input files
         to eliminate any "^^".
   
   Usually, the ind file is generated by TeX and contains
      the raw data to compose the index: the marked text,
      the type, a target destination number, the section,
      and the page.
   The ndx file contains the instructions to compose the
      entry: a regular expresion to select the references
      apropriate for this entry (checked against the marked
      text, a pair "}{", and the type), the entry text,
      and the type of the entry.

  Example lines:
   ndx
   \ndxentry/^[Aa]pariencia(s)?\}/apariencia/1/
   ind
   \ndxline{Apariencias}{11}{0012}{2}{8}
   abc
   \ndxline{apariencia}{1}{0012}{2}{8}

  Example use:
    $ index ndxfile < indfile > abcfile
      for each line of ndxfile
       compile the regular expression "^[Aa]pariencia(s)?\}"
       for each line of indfile
        if "Apariencias}{11" fits the regex pattern, 
         then compose an abcfile line
*/

#define BUFFERLENGTH 262144   /* buffer size for strings */

main(int argc, char *argv[]) {

 regex_t pattern;              /* the compiled pattern */
 char ndx[BUFFERLENGTH];       /* buffer containing the ndx file */
 char ind[BUFFERLENGTH];       /* buffer countaining de ind file */

 if (argc == 2) {
 
 /* si existe ndx lo leo a un buffer contando el número de líneas */
 int i, j, k, c;
 FILE *ndxf = fopen(argv[1],"r");
 int ndxn = 0; /* ndx num of '\n' (lines) */ 
 int ndxl = 0; /* ndx length */
 i = 0;
 while (i < BUFFERLENGTH - 1 && (c = getc(ndxf)) != EOF) {
  ndx[i++] = c;
  if (c == '\n') ++ndxn;
 }
 ndx[i++] = '\0';
 ndxl = i;
 fclose(ndxf);

 /* leo del stdin hasta el fin de fichero, contando líneas */
 int indn = 0; /* ind num of '\n' (lines) */ 
 int indl = 0; /* ind length */
 while (i < BUFFERLENGTH - 1 && (c = getchar()) != EOF) {
  ind[i++] = c;
  if (c == '\n') ++indn;
 }
 ind[i++] = '\0';
 indl = i;

 /* creo los arrays de punteros */
 int ndxp[3][ndxn];
 int indp[2][indn];
 for(i=0;i<3;++i) for(j=0;j<ndxn;++j) ndxp[i][j] = 0;
 for(i=0;i<2;++i) for(j=0;j<indn;++j) indp[i][j] = 0;
 /* y los que cuentan apariciones */
 int ndxc[ndxn]; for(i=0;i<ndxn;++i) ndxc[i] = 0;
 int indc[indn]; for(i=0;i<indn;++i) indc[i] = 0;
 
 /* tokenizo y preparo */
 /* ndx
   \ndxentry/^[Aa]pariencia(s)?\}/apariencia/1/n
   ind      0^                   0^         0^0n
   \ndxline{Apariencias}{11}{0012}{2}{8}n
   abc      ^              0^           0
   \ndxline{apariencia}{1}{0012}{2}{8}n
 */
 j = 0; k = 0;
 for (i = 0; i < ndxl; ++i) {
  c = ndx[i];
  if ( c == '\n' ) { k = 0; ++j; } 
  else if ( c == '/' ) {
   ndx[i] = '\0';
   if ( k < 3 ) ndxp[k++][j] = i + 1;
  }
 }
 j = 0; k = 0;
 for (i = 0; i < indl; ++i) {
  c = ind[i];
  if      ( c == '{' && k == 0) { indp[0][j] = i + 1; k++; } 
  else if ( c == '}' && k == 1) {                     k++; }
  else if ( c == '{' && k == 2) {                     k++; }
  else if ( c == '}' && k == 3) { ind[i] = '\0';      k++; }
  else if ( c == '{' && k == 4) { indp[1][j] = i;     k++; }
  else if ( c == '\n' )         { ind[i] = '\0'; ++j; k = 0; }
 }

 /* ejecuto el doble for */ 
 for (i=0; i<ndxn; ++i) {
  if ( ndx[ndxp[2][i]] == '-' ) {
   ndxc[i]++; 
   fputs("\\ndxline{", stdout);
   fputs(&ndx[ndxp[1][i]], stdout);
   fputs("}{", stdout);
   fputs(&ndx[ndxp[2][i]], stdout);
   fputs("}{0}{0}{0}\n", stdout);
  } else {
   regcomp(&pattern, &ndx[ ndxp[0][i] ], REG_EXTENDED);
   for (j=0; j<indn; ++j) {
    if ( !regexec(&pattern, &ind[indp[0][j]], 0, NULL, 0) ) {
     ndxc[i]++; indc[j]++;
     fputs("\\ndxline{", stdout);
     fputs(&ndx[ndxp[1][i]], stdout);
     fputs("}{", stdout);
     fputs(&ndx[ndxp[2][i]], stdout);
     fputs("}", stdout);
     fputs(&ind[indp[1][j]], stdout);
     fputs("\n", stdout);
    }
   }
   regfree(&pattern);  
  }
 } 
 /* acabado */
 for (i=0; i<ndxn; ++i) if (ndxc[i] == 0) {
  fprintf(stderr,"no ndx (%4d): \\ndxentry/%s/%s/%s/\n",
   i+1,&ndx[ndxp[0][i]],&ndx[ndxp[1][i]],&ndx[ndxp[2][i]]);
 }
 for (i=0; i<indn; ++i) if (indc[i] == 0) {
  fprintf(stderr,"no ind (%4d): \\ndxline{%s}%s\n",
   i+1,&ind[indp[0][i]],&ind[indp[1][i]]);
 } 
 
 }
 return 0; 
}
